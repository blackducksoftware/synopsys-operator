package actions

import (
	"fmt"
	"strings"

	blackduckv1 "github.com/blackducksoftware/synopsys-operator/pkg/api/blackduck/v1"
	bdutil "github.com/blackducksoftware/synopsys-operator/pkg/apps/util"
	"github.com/blackducksoftware/synopsys-operator/pkg/blackduck"
	blackduckclientset "github.com/blackducksoftware/synopsys-operator/pkg/blackduck/client/clientset/versioned"
	"github.com/blackducksoftware/synopsys-operator/pkg/util"
	"github.com/gobuffalo/buffalo"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Blackduck)
// DB Table: Plural (Hubs)
// Resource: Plural (Hubs)
// Path: Plural (/hubs)
// View Template Folder: Plural (/templates/hubs/)

// BlackducksResource is the resource for the Blackduck model
type BlackducksResource struct {
	buffalo.Resource
	kubeClient      *kubernetes.Clientset
	blackduckClient *blackduckclientset.Clientset
}

// NewHubResource will instantiate the Black Duck Resource
func NewHubResource(kubeConfig *rest.Config) (*BlackducksResource, error) {
	kubeClient, err := kubernetes.NewForConfig(kubeConfig)
	if err != nil {
		return nil, fmt.Errorf("unable to create kube client due to %+v", err)
	}
	hubClient, err := blackduckclientset.NewForConfig(kubeConfig)
	if err != nil {
		return nil, fmt.Errorf("unable to create hub client due to %+v", err)
	}
	return &BlackducksResource{kubeClient: kubeClient, blackduckClient: hubClient}, nil
}

// List gets all Hubs. This function is mapped to the path
// GET /hubs
func (v BlackducksResource) List(c buffalo.Context) error {
	blackducks, err := util.ListHubs(v.blackduckClient, "")
	if err != nil {
		return c.Error(500, err)
	}
	// Make blackducks available inside the html template
	c.Set("hubs", blackducks.Items)
	return c.Render(200, r.HTML("hubs/index.html", "old_application.html"))
}

// Show gets the data for one Blackduck. This function is mapped to
// the path GET /hubs/{hub_id}
func (v BlackducksResource) Show(c buffalo.Context) error {
	blackduck, err := util.GetHub(v.blackduckClient, c.Param("hub_id"), c.Param("hub_id"))
	if err != nil {
		return c.Error(500, err)
	}
	// Make blackduck available inside the html template
	c.Set("hub", blackduck)
	return c.Render(200, r.HTML("hubs/show.html", "old_application.html"))
}

// New renders the form for creating a new Blackduck.
// This function is mapped to the path GET /hubs/new
func (v BlackducksResource) New(c buffalo.Context) error {
	blackduckSpec := bdutil.GetHubDefaultValue()
	blackduck := &blackduckv1.Blackduck{}
	blackduck.Spec = *blackduckSpec
	blackduck.Spec.PersistentStorage = true
	blackduck.Spec.PVCStorageClass = ""
	blackduck.Spec.ScanType = "Artifacts"
	blackduck.Spec.PVC = []blackduckv1.PVC{
		{
			Name: "blackduck-postgres",
			Size: "150Gi",
		},
	}

	// Required so that the UI can update the fields
	blackduck.Spec.ExternalPostgres = &blackduckv1.PostgresExternalDBConfig{}
	err := v.common(c, blackduck)
	if err != nil {
		return err
	}
	// Make blackduck available inside the html template
	c.Set("hub", blackduck)

	return c.Render(200, r.HTML("hubs/new.html", "old_application.html"))
}

func (v BlackducksResource) common(c buffalo.Context, bd *blackduckv1.Blackduck) error {
	var storageList map[string]string
	storageList = make(map[string]string)
	storageClasses, err := util.ListStorageClass(v.kubeClient)
	if err != nil {
		c.Error(404, fmt.Errorf("\"message\": \"Failed to List the storage class due to %+v\"", err))
	}
	for _, storageClass := range storageClasses.Items {
		storageList[fmt.Sprintf("%s (%s)", storageClass.GetName(), storageClass.Provisioner)] = storageClass.GetName()
	}
	storageList[fmt.Sprintf("%s (%s)", "None", "Disable dynamic provisioner")] = ""
	bd.View.StorageClasses = storageList

	// Blackduck instances
	keys := make(map[string]string)
	hubs, _ := util.ListHubs(v.blackduckClient, "")
	for _, v := range hubs.Items {
		if strings.EqualFold(v.Status.State, "running") {
			keys[v.Name] = v.Name
		}
	}
	keys["None"] = ""
	bd.View.Clones = keys

	blackducks, _ := util.ListHubs(v.blackduckClient, "")
	certificateNames := []string{"default", "manual"}
	for _, hub := range blackducks.Items {
		if strings.EqualFold(hub.Spec.CertificateName, "manual") {
			certificateNames = append(certificateNames, hub.Spec.Namespace)
		}
	}
	bd.View.CertificateNames = certificateNames
	env, images := blackduck.GetHubKnobs()
	// env := map[string]string{}
	// images := []string{}
	environs := []string{}
	for key, value := range env {
		if !strings.EqualFold(value, "") {
			environs = append(environs, fmt.Sprintf("%s:%s", key, value))
		}
	}

	// environs := []string{"IPV4_ONLY:0", "HUB_PROXY_NON_PROXY_HOSTS:solr"}

	if len(bd.Spec.Environs) > 0 {
		bd.View.Environs = bd.Spec.Environs
	} else {
		bd.View.Environs = environs
	}

	if len(bd.Spec.ImageRegistries) > 0 {
		bd.View.ContainerTags = bd.Spec.ImageRegistries
	} else {
		bd.View.ContainerTags = images
	}
	return nil
}

func (v BlackducksResource) redirect(c buffalo.Context, blackduck *blackduckv1.Blackduck, err error) error {
	if err != nil {
		c.Flash().Add("warning", err.Error())
		// Make blackduck available inside the html template
		err = v.common(c, blackduck)
		if err != nil {
			log.Error(err)
			return err
		}
		log.Debugf("edit hub in create: %+v", blackduck)

		c.Set("hub", blackduck)

		// validateErrs := validate.NewErrors()
		// log.Infof("Error: %s", err.Error())
		// validateErrs.Add("error", err.Error())
		// log.Infof("validateErrs: %+v", validateErrs)
		// validateErrs.Errors = map[string][]string{"error": []string{errors.WithStack(err).Error()}}
		// c.Set("errors", err.Error())
		return c.Render(422, r.HTML("hubs/new.html", "old_application.html"))
	}
	return nil
}

// Create adds a Blackduck to the DB. This function is mapped to the
// path POST /hubs
func (v BlackducksResource) Create(c buffalo.Context) error {
	// Allocate an empty Blackduck
	hub := &blackduckv1.Blackduck{}

	// Bind blackduck to the html form elements
	if err := c.Bind(hub); err != nil {
		log.Errorf("unable to bind blackduck %+v because %+v", c, err)
		return errors.WithStack(err)
	}

	log.Infof("create hub: %+v", hub)

	_, err := util.GetHub(v.blackduckClient, hub.Spec.Namespace, hub.Spec.Namespace)

	if err == nil {
		return v.redirect(c, hub, fmt.Errorf("hub %s already exist", hub.Spec.Namespace))
	}

	_, err = util.GetNamespace(v.kubeClient, hub.Spec.Namespace)

	if err == nil {
		return v.redirect(c, hub, fmt.Errorf("namespace %s already exist", hub.Spec.Namespace))
	}

	ns, err := util.CreateNamespace(v.kubeClient, hub.Spec.Namespace)
	if err != nil {
		return v.redirect(c, hub, err)
	}
	log.Infof("created namespace for %s is %+v", hub.Spec.Namespace, ns)

	// Change back to nil if the configuration is empty
	if *hub.Spec.ExternalPostgres == (blackduckv1.PostgresExternalDBConfig{}) {
		log.Info("External Database configuration is empty")
		hub.Spec.ExternalPostgres = nil
	}
	_, err = util.CreateHub(v.blackduckClient, hub.Spec.Namespace, &blackduckv1.Blackduck{ObjectMeta: metav1.ObjectMeta{Name: hub.Spec.Namespace}, Spec: hub.Spec})

	if err != nil {
		return v.redirect(c, hub, err)
	}
	// If there are no errors set a success message
	c.Flash().Add("success", "Blackduck was created successfully")

	blackducks, _ := util.ListHubs(v.blackduckClient, "")
	c.Set("hubs", blackducks.Items)
	// and redirect to the blackducks index page
	return c.Redirect(302, "/hubs/%s", hub.Spec.Namespace)
}

// Edit renders a edit form for a Blackduck. This function is
// mapped to the path GET /hubs/{hub_id}/edit
func (v BlackducksResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	// tx, ok := c.Value("tx").(*pop.Connection)
	// if !ok {
	// 	return errors.WithStack(errors.New("no transaction found"))
	// }

	// // Allocate an empty Blackduck
	// blackduck := &v1.Blackduck{}

	// if err := tx.Find(blackduck, c.Param("blackduck_id")); err != nil {
	// 	return c.Error(404, err)
	// }

	// return c.Render(200, r.Auto(c, blackduck))
	return c.Error(404, errors.New("resource not implemented"))

}

// Update changes a Blackduck in the DB. This function is mapped to
// the path PUT /hubs/{hub_id}
func (v BlackducksResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	// tx, ok := c.Value("tx").(*pop.Connection)
	// if !ok {
	// 	return errors.WithStack(errors.New("no transaction found"))
	// }

	// // Allocate an empty Blackduck
	// blackduck := &v1.Blackduck{}

	// if err := tx.Find(blackduck, c.Param("blackduck_id")); err != nil {
	// 	return c.Error(404, err)
	// }

	// // Bind Blackduck to the html form elements
	// if err := c.Bind(blackduck); err != nil {
	// 	return errors.WithStack(err)
	// }

	// verrs, err := tx.ValidateAndUpdate(blackduck)
	// if err != nil {
	// 	return errors.WithStack(err)
	// }

	// if verrs.HasAny() {
	// 	// Make the errors available inside the html template
	// 	c.Set("errors", verrs)

	// 	// Render again the edit.html template that the user can
	// 	// correct the input.
	// 	return c.Render(422, r.Auto(c, blackduck))
	// }

	// // If there are no errors set a success message
	// c.Flash().Add("success", "Blackduck was updated successfully")

	// and redirect to the blackducks index page
	return c.Error(404, errors.New("resource not implemented"))
}

// Destroy deletes a Blackduck from the DB. This function is mapped
// to the path DELETE /hubs/{hub_id}
func (v BlackducksResource) Destroy(c buffalo.Context) error {

	log.Infof("delete hub request %v", c.Param("hub_id"))

	_, err := util.GetHub(v.blackduckClient, c.Param("hub_id"), c.Param("hub_id"))
	// To find the Blackduck the parameter blackduck_id is used.
	if err != nil {
		return c.Error(404, err)
	}

	// This is on the event loop.
	err = v.blackduckClient.SynopsysV1().Blackducks(c.Param("hub_id")).Delete(c.Param("hub_id"), &metav1.DeleteOptions{})

	// To find the Blackduck the parameter blackduck_id is used.
	if err != nil {
		return c.Error(404, err)
	}

	// If there are no errors set a flash message
	c.Flash().Add("success", "Blackduck was deleted successfully")

	// blackducks, _ := util.ListHubs(v.blackduckClient, "")
	// c.Set("hubs", blackducks.Items)

	// Redirect to the blackducks index page
	return c.Redirect(302, "/hubs")
}
